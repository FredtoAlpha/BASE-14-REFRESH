<script>
/**
 * GROUPS MODULE V4 - LOADER
 * Connecte l'interface triptyque au bouton Groupes du header
 * et fait le pont avec l'algorithme de r√©partition
 */

(function() {
  'use strict';

  console.log('üîå Initialisation du module Groupes V4...');

  // Container plein √©cran pour l'interface
  let moduleContainer = null;

  // Cache pour les donn√©es FIN
  let finSheetsDataCache = null;

  /**
   * Charge les donn√©es depuis les onglets FIN avec scores (colonnes U et V)
   */
  async function loadFINData() {
    if (finSheetsDataCache) {
      console.log('üì¶ Utilisation du cache FIN');
      return finSheetsDataCache;
    }

    console.log('üì° Chargement des onglets FIN avec SCORE F (col U) et SCORE M (col V)...');

    try {
      const result = await gsRun('loadFINSheetsWithScores');

      if (!result || !result.success || !result.data) {
        console.error('‚ùå loadFINSheetsWithScores a retourn√© un format invalide:', result);
        return null;
      }

      // Extraire les donn√©es (result.data contient { "6¬∞1FIN": { eleves: [...] }, ... })
      finSheetsDataCache = result.data;
      console.log('‚úÖ Donn√©es FIN charg√©es:', Object.keys(result.data));
      return result.data;
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des onglets FIN:', error);
      return null;
    }
  }

  // ========== SYST√àME DE REPORTING CENTRALIS√â ==========
  const ErrorReporter = {
    errors: [],
    warnings: [],

    error(context, message, data = null) {
      const entry = { context, message, data, timestamp: new Date().toISOString() };
      this.errors.push(entry);
      console.error(`‚ùå [${context}] ${message}`, data || '');
      return entry;
    },

    warn(context, message, data = null) {
      const entry = { context, message, data, timestamp: new Date().toISOString() };
      this.warnings.push(entry);
      console.warn(`‚ö†Ô∏è [${context}] ${message}`, data || '');
      return entry;
    },

    info(context, message, data = null) {
      console.log(`‚ÑπÔ∏è [${context}] ${message}`, data || '');
    },

    getReport() {
      return {
        errors: this.errors,
        warnings: this.warnings,
        summary: `${this.errors.length} erreur(s), ${this.warnings.length} avertissement(s)`
      };
    },

    clear() {
      this.errors = [];
      this.warnings = [];
    },

    displayToUser() {
      if (this.errors.length === 0 && this.warnings.length === 0) return;

      const report = this.getReport();
      const message = `‚ö†Ô∏è Rapport de chargement:\n\n${report.summary}\n\n` +
        (this.errors.length > 0 ? `Erreurs:\n${this.errors.map(e => `- ${e.message}`).join('\n')}` : '') +
        (this.warnings.length > 0 ? `\n\nAvertissements:\n${this.warnings.map(w => `- ${w.message}`).join('\n')}` : '');

      if (this.errors.length > 0) {
        alert(message);
      } else {
        console.warn(message);
      }
    }
  };

  // ========== VALIDATION ET NORMALISATION DES DONN√âES ==========

  /**
   * V√©rifie si un objet ressemble √† un √©l√®ve valide
   * @param {*} obj - Objet √† v√©rifier
   * @returns {boolean} true si l'objet est un √©l√®ve valide
   */
  function isStudentLike(obj) {
    if (!obj || typeof obj !== 'object') {
      return false;
    }

    // Un √©l√®ve DOIT avoir un ID
    if (!obj.id || typeof obj.id !== 'string' || obj.id.trim() === '') {
      return false;
    }

    // Optionnel mais recommand√© : nom et pr√©nom
    const hasName = (obj.nom || obj.prenom);

    // Accepter si au moins l'ID est pr√©sent
    return true;
  }

  /**
   * Normalise les donn√©es d'une classe depuis le format FIN
   * @param {string} className - Nom de la classe
   * @param {*} classData - Donn√©es brutes de la classe
   * @returns {Array|null} Tableau d'√©l√®ves normalis√©s ou null si invalide
   */
  function normalizeClassStudents(className, classData) {
    if (!classData) {
      ErrorReporter.error('normalizeClassStudents', `Classe ${className}: donn√©es nulles ou undefined`);
      return null;
    }

    // Extraire le tableau d'√©l√®ves (format: { eleves: [...] } ou directement [...])
    let students = classData.eleves || classData;

    // V√©rifier que students est un tableau
    if (!Array.isArray(students)) {
      ErrorReporter.error('normalizeClassStudents',
        `Classe ${className}: students n'est pas un tableau`,
        { type: typeof students, value: students }
      );
      return null;
    }

    // Filtrer et normaliser les √©l√®ves
    const normalized = [];
    let skippedCount = 0;

    students.forEach((student, index) => {
      // Valider que c'est un √©l√®ve
      if (!isStudentLike(student)) {
        ErrorReporter.warn('normalizeClassStudents',
          `Classe ${className}: √©l√®ve #${index} invalide (pas d'ID ou format incorrect)`,
          student
        );
        skippedCount++;
        return;
      }

      // Normaliser l'√©l√®ve
      try {
        const normalizedStudent = {
          id: student.id,
          firstName: student.prenom || '',
          lastName: student.nom || '',
          class: className,

          // SEXE
          sexe: (student.sexe || 'M').toUpperCase(),
          gender: student.sexe || 'M',

          // CRIT√àRES COMPORTEMENTAUX
          com: student.scores?.COM || student.com || 0,
          tra: student.scores?.TRA || student.tra || 0,
          part: student.scores?.PART || student.part || 0,
          abs: student.scores?.ABS || student.abs || 0,

          // SCORES ACAD√âMIQUES (COLONNES U ET V DES ONGLETS FIN)
          scoreF: student.scoreF || student.scores?.F || 0,  // Colonne U (1-4)
          scoreM: student.scoreM || student.scores?.M || 0,  // Colonne V (1-4)
          score: student.scoreF || student.scores?.F || 0,

          // AUTRES DONN√âES
          lv2: (student.lv2 || 'ESP').toUpperCase(),
          options: student.options || [],
          scores: student.scores || {}
        };

        // Avertir si les scores acad√©miques sont absents
        if (normalizedStudent.scoreF === 0 && normalizedStudent.scoreM === 0) {
          ErrorReporter.warn('normalizeClassStudents',
            `Classe ${className}: √©l√®ve ${student.id} sans scores acad√©miques (scoreF et scoreM √† 0)`
          );
        }

        normalized.push(normalizedStudent);
      } catch (error) {
        ErrorReporter.error('normalizeClassStudents',
          `Classe ${className}: erreur lors de la normalisation de l'√©l√®ve #${index}`,
          { error: error.message, student }
        );
        skippedCount++;
      }
    });

    // Rapport final pour cette classe
    if (skippedCount > 0) {
      ErrorReporter.warn('normalizeClassStudents',
        `Classe ${className}: ${skippedCount} √©l√®ve(s) ignor√©(s) sur ${students.length}`
      );
    }

    ErrorReporter.info('normalizeClassStudents',
      `Classe ${className}: ${normalized.length} √©l√®ve(s) normalis√©(s) avec succ√®s`
    );

    return normalized.length > 0 ? normalized : null;
  }

  /**
   * R√©cup√®re les donn√©es des classes depuis les onglets FIN (avec scores acad√©miques)
   * IMPORTANT: Cette fonction charge DIRECTEMENT depuis les onglets FIN pour avoir
   * acc√®s aux colonnes SCORE F (U) et SCORE M (V)
   */
  function getClassesData() {
    // R√©initialiser le rapport d'erreurs
    ErrorReporter.clear();

    // Si nous avons d√©j√† charg√© les donn√©es FIN en cache, les utiliser
    if (finSheetsDataCache) {
      ErrorReporter.info('getClassesData', 'Utilisation des donn√©es FIN en cache');

      const formattedData = {};

      Object.keys(finSheetsDataCache).forEach(className => {
        const classData = finSheetsDataCache[className];

        // Utiliser la fonction de normalisation
        const normalizedStudents = normalizeClassStudents(className, classData);

        if (normalizedStudents && normalizedStudents.length > 0) {
          formattedData[className] = normalizedStudents;
        } else {
          ErrorReporter.warn('getClassesData',
            `Classe ${className} ignor√©e (aucun √©l√®ve valide apr√®s normalisation)`
          );
        }
      });

      // Afficher le rapport
      ErrorReporter.info('getClassesData',
        `Donn√©es FIN format√©es: ${Object.keys(formattedData).length} classe(s)`
      );
      ErrorReporter.info('getClassesData',
        'D√©tail: ' + Object.entries(formattedData).map(([c, eleves]) => `${c}: ${eleves.length} √©l√®ves`).join(', ')
      );

      // Afficher les erreurs/warnings √† l'utilisateur si n√©cessaire
      if (ErrorReporter.errors.length > 0) {
        ErrorReporter.displayToUser();
      }

      return formattedData;
    }

    // Sinon, fallback sur STATE.students (mode legacy)
    if (!window.STATE || !window.STATE.students) {
      console.error('‚ùå window.STATE.students non disponible et pas de cache FIN');
      return null;
    }

    console.warn('‚ö†Ô∏è Fallback sur STATE.students (peut ne pas contenir les scores acad√©miques)');

    // Extraire les classes depuis les zones droppables du DOM
    const zones = document.querySelectorAll('.droppable-zone[data-classe]');
    const classesData = {};

    zones.forEach(zone => {
      const className = zone.getAttribute('data-classe');
      if (!className) return;

      classesData[className] = [];

      // R√©cup√©rer les cartes √©l√®ves dans cette zone
      const cards = zone.querySelectorAll('.student-card');

      cards.forEach(card => {
        const studentId = card.getAttribute('data-id') || card.getAttribute('data-student-id');
        if (!studentId) return;

        // R√©cup√©rer les donn√©es compl√®tes depuis STATE
        const student = window.STATE.students[studentId];

        if (student) {
          // Extraire TOUS les champs n√©cessaires pour l'algorithme V4
          classesData[className].push({
            id: student.id || studentId,
            firstName: student.firstName || student.prenom || '',
            lastName: student.lastName || student.nom || '',
            class: className,

            // SEXE (colonne E)
            sexe: (student.sexe || student.gender || 'M').toUpperCase(),
            gender: student.gender || student.sexe || 'M',

            // CRIT√àRES COMPORTEMENTAUX
            com: student.com || student.COM || 0,        // Colonne H
            tra: student.tra || student.TRA || 0,        // Colonne I
            part: student.part || student.PART || 0,     // Colonne J
            abs: student.abs || student.ABS || 0,        // Colonne K

            // SCORES ACAD√âMIQUES
            scoreF: student.scoreF || student.scores?.F || 0,  // Colonne U (1-4)
            scoreM: student.scoreM || student.scores?.M || 0,  // Colonne V (1-4)
            score: student.score || student.scoreF || student.scoreM || 0,

            // AUTRES DONN√âES
            // Colonne F : LV2 (ESP par d√©faut si vide)
            lv2: (student.lv2 || student.LV2 || 'ESP').toUpperCase(),
            options: student.options || [],
            scores: student.scores || {}
          });
        }
      });
    });

    console.log('üìä Donn√©es des classes extraites:', Object.keys(classesData));
    console.log('üìä D√©tail:', Object.entries(classesData).map(([c, eleves]) => `${c}: ${eleves.length} √©l√®ves`));

    return classesData;
  }

  /**
   * V√©rifie que les donn√©es sont disponibles
   */
  function validateData() {
    const classesData = getClassesData();

    if (!classesData || Object.keys(classesData).length === 0) {
      console.error('‚ùå Aucune classe trouv√©e dans STATE');
      console.log('Diagnostic :');
      console.log('- STATE existe :', !!window.STATE);
      console.log('- STATE.students existe :', !!window.STATE?.students);
      console.log('- Nombre d\'√©l√®ves :', Object.keys(window.STATE?.students || {}).length);
      return false;
    }

    return true;
  }

  /**
   * Ouvre l'interface du module Groupes V4
   * CHARGE AUTOMATIQUEMENT LES ONGLETS FIN AVEC SCORES (colonnes U et V)
   */
  async function openModuleGroupsV4(mode) {
    console.log('üöÄ Ouverture du module Groupes V4, mode:', mode);

    // V√©rifier les d√©pendances
    if (!window.GroupsInterfaceV4) {
      console.error('‚ùå GroupsInterfaceV4 non charg√©');
      alert('Erreur : Interface Groupes V4 non disponible');
      return;
    }

    if (!window.GroupsAlgorithmV4) {
      console.error('‚ùå GroupsAlgorithmV4 non charg√©');
      alert('Erreur : Algorithme Groupes V4 non disponible');
      return;
    }

    // üîë CHARGER LES DONN√âES FIN AVEC SCORES (colonnes U et V)
    console.log('üì° Chargement des onglets FIN avec SCORE F (colonne U) et SCORE M (colonne V)...');
    const finData = await loadFINData();

    if (!finData || Object.keys(finData).length === 0) {
      console.error('‚ùå Aucune donn√©e FIN charg√©e');

      // Fallback sur STATE.students
      console.warn('‚ö†Ô∏è Fallback sur STATE.students...');

      // V√©rifier que STATE.students est charg√©
      if (!window.STATE || !window.STATE.students || Object.keys(window.STATE.students).length === 0) {
        console.warn('‚ö†Ô∏è STATE.students vide ou non charg√©, attente...');

        // Attendre 1 seconde que les donn√©es se chargent
        setTimeout(() => {
          if (!window.STATE || !window.STATE.students || Object.keys(window.STATE.students).length === 0) {
            alert('Erreur : Les donn√©es des √©l√®ves ne sont pas encore charg√©es. Veuillez attendre la fin du chargement et r√©essayer.');
            console.error('‚ùå STATE.students toujours vide apr√®s d√©lai');
            return;
          }
          // R√©essayer l'ouverture
          openModuleGroupsV4(mode);
        }, 1000);
        return;
      }

      // Valider les donn√©es
      if (!validateData()) {
        alert('Erreur : Aucune classe disponible. Veuillez charger des donn√©es d\'abord.');
        return;
      }
    } else {
      console.log('‚úÖ Donn√©es FIN charg√©es avec succ√®s:', Object.keys(finData).length, 'classes');
    }

    // Cr√©er le container plein √©cran
    if (!moduleContainer) {
      moduleContainer = document.createElement('div');
      moduleContainer.id = 'groups-v4-container';
      moduleContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 9999;
        background: white;
      `;

      // Ajouter un bouton de fermeture
      const closeBtn = document.createElement('button');
      closeBtn.innerHTML = '<i class="fas fa-times"></i> Fermer';
      closeBtn.style.cssText = `
        position: absolute;
        top: 16px;
        right: 16px;
        z-index: 10000;
        padding: 8px 16px;
        background: #ef4444;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      `;
      closeBtn.addEventListener('click', closeModuleGroupsV4);

      moduleContainer.appendChild(closeBtn);
      document.body.appendChild(moduleContainer);
    }

    // Rendre l'interface triptyque
    window.GroupsInterfaceV4.renderInitialStructure(moduleContainer);

    // Afficher le container
    moduleContainer.style.display = 'block';

    console.log('‚úÖ Module Groupes V4 ouvert');
  }

  /**
   * Ferme l'interface du module
   */
  function closeModuleGroupsV4() {
    if (moduleContainer) {
      moduleContainer.style.display = 'none';
      console.log('‚úÖ Module Groupes V4 ferm√©');
    }
  }

  /**
   * G√®re l'√©v√©nement de g√©n√©ration des groupes
   */
  function handleGenerateGroups(event) {
    const { scenario, mode, selectedLanguage, regroupements } = event.detail;

    console.log('üéØ G√©n√©ration des groupes demand√©e:', { scenario, mode, selectedLanguage, regroupements });

    try {
      // Pour chaque regroupement, g√©n√©rer les groupes
      const allResults = regroupements.map(regroupement => {
        // R√©cup√©rer les √©l√®ves des classes du regroupement
        const classesData = getClassesData();
        let students = [];

        // Si aucune classe sp√©cifi√©e, prendre toutes les classes
        const classesToUse = regroupement.classes.length > 0
          ? regroupement.classes
          : Object.keys(classesData);

        classesToUse.forEach(className => {
          if (classesData[className]) {
            students.push(...classesData[className]);
          }
        });

        console.log(`üìö Regroupement "${regroupement.name}" : ${students.length} √©l√®ves (avant filtrage)`);

        // FILTRAGE PAR LANGUE pour le sc√©nario LV2
        if (scenario === 'lv2' && selectedLanguage) {
          const beforeFilter = students.length;
          students = students.filter(student => {
            const studentLang = (student.lv2 || 'ESP').toUpperCase();
            return studentLang === selectedLanguage;
          });
          console.log(`üåç Filtrage LV2 (${selectedLanguage}): ${beforeFilter} ‚Üí ${students.length} √©l√®ves`);
        }

        if (students.length === 0) {
          console.warn(`‚ö†Ô∏è Aucun √©l√®ve pour "${regroupement.name}" apr√®s filtrage`);
          return null;
        }

        console.log(`üìö Regroupement "${regroupement.name}" : ${students.length} √©l√®ves (apr√®s filtrage)`);

        // Appeler l'algorithme
        const result = window.GroupsAlgorithmV4.distribute({
          students,
          mode,
          numGroups: regroupement.numGroups,
          scenario
        });

        return {
          regroupement: regroupement.name,
          result
        };
      });

      // Filtrer les r√©sultats null (regroupements vides)
      const validResults = allResults.filter(r => r !== null);

      if (validResults.length === 0) {
        throw new Error('Aucun √©l√®ve trouv√© apr√®s filtrage. V√©rifiez la langue s√©lectionn√©e et les classes.');
      }

      // Combiner les r√©sultats en pr√©servant l'information du regroupement
      const combinedResults = {
        groups: validResults.flatMap(r =>
          r.result.groups.map(group => ({
            ...group,
            regroupementName: r.regroupement, // Ajouter le nom du regroupement
            regroupementId: r.regroupement.replace(/\s+/g, '-').toLowerCase()
          }))
        ),
        stats: validResults.flatMap(r => r.result.stats),
        metadata: {
          scenario,
          mode,
          selectedLanguage,
          totalRegroupements: validResults.length,
          totalStudents: validResults.reduce((sum, r) => sum + r.result.metadata.totalStudents, 0),
          timestamp: new Date().toISOString()
        }
      };

      // √âmettre l'√©v√©nement de succ√®s
      const successEvent = new CustomEvent('groups:generated', {
        detail: combinedResults
      });
      document.dispatchEvent(successEvent);

      console.log('‚úÖ Groupes g√©n√©r√©s avec succ√®s', combinedResults);

    } catch (error) {
      console.error('‚ùå Erreur lors de la g√©n√©ration:', error);

      // √âmettre l'√©v√©nement d'erreur
      const errorEvent = new CustomEvent('groups:error', {
        detail: { message: error.message }
      });
      document.dispatchEvent(errorEvent);
    }
  }

  /**
   * G√®re l'√©v√©nement de r√©sultats g√©n√©r√©s
   */
  function handleGroupsGenerated(event) {
    console.log('üìä R√©sultats re√ßus:', event.detail);

    // Afficher les r√©sultats dans l'interface
    if (window.GroupsInterfaceV4) {
      window.GroupsInterfaceV4.displayResults(event.detail);
    }
  }

  /**
   * G√®re l'√©v√©nement d'erreur
   */
  function handleGroupsError(event) {
    console.error('‚ùå Erreur re√ßue:', event.detail);

    // Afficher l'erreur dans l'interface
    if (window.GroupsInterfaceV4) {
      window.GroupsInterfaceV4.displayError(event.detail);
    }
  }

  /**
   * Remplace la fonction openGroupsInterface existante
   */
  function replaceOpenGroupsInterface() {
    // Sauvegarder l'ancienne fonction si elle existe
    if (window.openGroupsInterface) {
      window._oldOpenGroupsInterface = window.openGroupsInterface;
      console.log('üíæ Ancienne openGroupsInterface sauvegard√©e');
    }

    // Remplacer par la nouvelle
    window.openGroupsInterface = function(mode) {
      console.log('üîÑ openGroupsInterface appel√©e avec mode:', mode);

      // Rediriger vers le module V4
      openModuleGroupsV4(mode);
    };

    console.log('‚úÖ openGroupsInterface remplac√©e par la version V4');
  }

  /**
   * Restaure l'ancienne fonction openGroupsInterface
   */
  function restoreOpenGroupsInterface() {
    if (window._oldOpenGroupsInterface) {
      window.openGroupsInterface = window._oldOpenGroupsInterface;
      delete window._oldOpenGroupsInterface;
      console.log('‚úÖ openGroupsInterface restaur√©e');
    }
  }

  /**
   * Initialisation du module
   */
  function init() {
    // √âcouter les √©v√©nements
    document.addEventListener('groups:generate', handleGenerateGroups);
    document.addEventListener('groups:generated', handleGroupsGenerated);
    document.addEventListener('groups:error', handleGroupsError);

    // Remplacer la fonction du header
    replaceOpenGroupsInterface();

    // Exposer les fonctions globalement
    window.openModuleGroupsV4 = openModuleGroupsV4;
    window.closeModuleGroupsV4 = closeModuleGroupsV4;

    console.log('‚úÖ Module Groupes V4 initialis√© et connect√© au header');
  }

  // Initialiser au chargement du DOM
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    // DOM d√©j√† charg√©
    setTimeout(init, 100);
  }

  // Nettoyer √† la fermeture
  window.addEventListener('beforeunload', () => {
    restoreOpenGroupsInterface();
  });

})();
</script>
