<script>
/**
 * GROUPS MODULE V4 - LOADER
 * Connecte l'interface triptyque au bouton Groupes du header
 * et fait le pont avec l'algorithme de r√©partition
 */

(function() {
  'use strict';

  console.log('üîå Initialisation du module Groupes V4...');

  // Container plein √©cran pour l'interface
  let moduleContainer = null;

  // Cache pour les donn√©es FIN
  let finSheetsDataCache = null;

  /**
   * Charge les donn√©es depuis les onglets FIN avec scores (colonnes U et V)
   */
  async function loadFINData() {
    if (finSheetsDataCache) {
      console.log('üì¶ Utilisation du cache FIN');
      return finSheetsDataCache;
    }

    console.log('üì° Chargement des onglets FIN avec SCORE F (col U) et SCORE M (col V)...');

    try {
      const result = await gsRun('loadFINSheetsWithScores');

      if (!result || !result.success || !result.data) {
        console.error('‚ùå loadFINSheetsWithScores a retourn√© un format invalide:', result);
        return null;
      }

      // Extraire les donn√©es (result.data contient { "6¬∞1FIN": { eleves: [...] }, ... })
      finSheetsDataCache = result.data;
      console.log('‚úÖ Donn√©es FIN charg√©es:', Object.keys(result.data));
      return result.data;
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des onglets FIN:', error);
      return null;
    }
  }

  // ========== SYST√àME DE REPORTING CENTRALIS√â ==========
  const ErrorReporter = {
    errors: [],
    warnings: [],

    error(context, message, data = null) {
      const entry = { context, message, data, timestamp: new Date().toISOString() };
      this.errors.push(entry);
      console.error(`‚ùå [${context}] ${message}`, data || '');
      return entry;
    },

    warn(context, message, data = null) {
      const entry = { context, message, data, timestamp: new Date().toISOString() };
      this.warnings.push(entry);
      console.warn(`‚ö†Ô∏è [${context}] ${message}`, data || '');
      return entry;
    },

    info(context, message, data = null) {
      console.log(`‚ÑπÔ∏è [${context}] ${message}`, data || '');
    },

    getReport() {
      return {
        errors: this.errors,
        warnings: this.warnings,
        summary: `${this.errors.length} erreur(s), ${this.warnings.length} avertissement(s)`
      };
    },

    clear() {
      this.errors = [];
      this.warnings = [];
    },

    displayToUser() {
      if (this.errors.length === 0 && this.warnings.length === 0) return;

      const report = this.getReport();
      const message = `‚ö†Ô∏è Rapport de chargement:\n\n${report.summary}\n\n` +
        (this.errors.length > 0 ? `Erreurs:\n${this.errors.map(e => `- ${e.message}`).join('\n')}` : '') +
        (this.warnings.length > 0 ? `\n\nAvertissements:\n${this.warnings.map(w => `- ${w.message}`).join('\n')}` : '');

      if (this.errors.length > 0) {
        alert(message);
      } else {
        console.warn(message);
      }
    }
  };

  // ========== VALIDATION ET NORMALISATION DES DONN√âES ==========

  /**
   * V√©rifie si un objet ressemble √† un √©l√®ve valide
   * @param {*} obj - Objet √† v√©rifier
   * @returns {boolean} true si l'objet est un √©l√®ve valide
   */
  function isStudentLike(obj) {
    if (!obj || typeof obj !== 'object') {
      return false;
    }

    // Un √©l√®ve DOIT avoir un ID
    if (!obj.id || typeof obj.id !== 'string' || obj.id.trim() === '') {
      return false;
    }

    // Optionnel mais recommand√© : nom et pr√©nom
    const hasName = (obj.nom || obj.prenom);

    // Accepter si au moins l'ID est pr√©sent
    return true;
  }

  /**
   * Collecte r√©cursivement tous les objets √©l√®ves dans une structure de donn√©es
   * Parcourt en profondeur pour g√©rer des imbrications complexes (Apps Script)
   * @param {*} data - Structure de donn√©es √† parcourir
   * @param {Set} seen - Set des IDs d√©j√† vus (pour d√©duplication)
   * @param {number} depth - Profondeur actuelle (limite √† 10 pour √©viter boucles infinies)
   * @returns {Array} Tableau d'objets √©l√®ves d√©dupliqu√©s
   */
  function collectStudentsRecursive(data, seen = new Set(), depth = 0) {
    const MAX_DEPTH = 10;
    const students = [];

    // Garde contre r√©cursion infinie
    if (depth > MAX_DEPTH) {
      ErrorReporter.warn('collectStudentsRecursive', `Profondeur maximale atteinte (${MAX_DEPTH})`);
      return students;
    }

    // Cas null/undefined
    if (data == null) {
      return students;
    }

    // Cas primitif (string, number, boolean)
    if (typeof data !== 'object') {
      return students;
    }

    // Cas tableau
    if (Array.isArray(data)) {
      data.forEach((item, index) => {
        // Si c'est un √©l√®ve, l'ajouter
        if (isStudentLike(item)) {
          // D√©duplication par ID
          if (!seen.has(item.id)) {
            seen.add(item.id);
            students.push(item);
          }
        } else {
          // Sinon, parcourir r√©cursivement
          const nested = collectStudentsRecursive(item, seen, depth + 1);
          students.push(...nested);
        }
      });
      return students;
    }

    // Cas objet
    if (typeof data === 'object') {
      // Si l'objet lui-m√™me est un √©l√®ve
      if (isStudentLike(data)) {
        if (!seen.has(data.id)) {
          seen.add(data.id);
          students.push(data);
        }
        return students;
      }

      // Sinon, parcourir toutes les propri√©t√©s
      Object.keys(data).forEach(key => {
        const value = data[key];
        const nested = collectStudentsRecursive(value, seen, depth + 1);
        students.push(...nested);
      });

      return students;
    }

    return students;
  }

  /**
   * Pr√©pare un √©l√®ve pour l'algorithme V4 avec gardes renforc√©es et valeurs de repli
   * TOUS les champs critiques pour l'algorithme sont valid√©s et normalis√©s
   * @param {Object} student - Objet √©l√®ve brut
   * @param {string} className - Nom de la classe (pour contexte)
   * @returns {Object} √âl√®ve normalis√© avec tous les champs requis
   */
  function prepareStudentForAlgorithm(student, className) {
    // ========== CHAMPS IDENTIT√â ==========
    const id = String(student.id || '').trim();
    const firstName = String(student.prenom || student.firstName || '').trim();
    const lastName = String(student.nom || student.lastName || '').trim();

    // ========== SEXE (CRITIQUE POUR PARIT√â) ==========
    let sexe = String(student.sexe || student.gender || 'M').trim().toUpperCase();
    // Normaliser : accepter F/M/FEMME/HOMME/FILLE/GARCON
    if (sexe.startsWith('F') || sexe === 'FEMME' || sexe === 'FILLE') {
      sexe = 'F';
    } else if (sexe.startsWith('M') || sexe === 'HOMME' || sexe === 'GARCON') {
      sexe = 'M';
    } else {
      // Valeur invalide ‚Üí warning et fallback M
      ErrorReporter.warn('prepareStudentForAlgorithm',
        `Classe ${className}: √©l√®ve ${id} a un sexe invalide "${sexe}", fallback sur M`
      );
      sexe = 'M';
    }

    // ========== SCORES ACAD√âMIQUES (CRITIQUES POUR Z-SCORES V4) ==========
    // Extraction multi-source avec garde de type
    const extractScore = (sources, defaultValue = 0) => {
      for (const source of sources) {
        const value = parseFloat(source);
        if (!isNaN(value) && isFinite(value)) {
          // Clamp entre 0 et 4 (√©chelle FIN)
          return Math.max(0, Math.min(4, value));
        }
      }
      return defaultValue;
    };

    const scoreF = extractScore([
      student.scoreF,
      student.scores?.F,
      student.scores?.SCOREF,
      student.besoinsF
    ]);

    const scoreM = extractScore([
      student.scoreM,
      student.scores?.M,
      student.scores?.SCOREM,
      student.besoinsM
    ]);

    // ========== CRIT√àRES COMPORTEMENTAUX (POUR Z-SCORES V4) ==========
    const com = extractScore([student.scores?.COM, student.com]);
    const tra = extractScore([student.scores?.TRA, student.tra]);
    const part = extractScore([student.scores?.PART, student.part]);
    const abs = extractScore([student.scores?.ABS, student.abs]);

    // ========== LV2 (POUR CRIT√àRES OPTIONNELS) ==========
    let lv2 = String(student.lv2 || student.LV2 || 'ESP').trim().toUpperCase();
    // Normaliser les abr√©viations
    const lv2Map = {
      'ESPAGNOL': 'ESP', 'ESPA': 'ESP', 'SPA': 'ESP',
      'ALLEMAND': 'ALL', 'ALLEM': 'ALL', 'GER': 'ALL',
      'ITALIEN': 'ITA', 'ITAL': 'ITA',
      'ANGLAIS': 'ANG', 'ANGL': 'ANG', 'ENG': 'ANG'
    };
    lv2 = lv2Map[lv2] || lv2;

    // ========== OPTIONS (POUR QUOTAS) ==========
    let options = student.options || [];
    if (!Array.isArray(options)) {
      if (typeof options === 'string') {
        options = options.split(',').map(o => o.trim()).filter(Boolean);
      } else {
        options = [];
      }
    }
    // Normaliser en majuscules
    options = options.map(opt => String(opt).toUpperCase());

    // ========== CONSTRUIRE L'OBJET NORMALIS√â ==========
    const normalized = {
      // Identit√©
      id,
      firstName,
      lastName,
      class: className,

      // Sexe (format dual pour compatibilit√©)
      sexe,
      gender: sexe,

      // Scores acad√©miques (CRITIQUES)
      scoreF,
      scoreM,
      score: scoreF,  // Alias pour compatibilit√©

      // Crit√®res comportementaux
      com,
      tra,
      part,
      abs,

      // Autres
      lv2,
      options,

      // Objet scores consolid√©
      scores: {
        F: scoreF,
        M: scoreM,
        COM: com,
        TRA: tra,
        PART: part,
        ABS: abs
      }
    };

    // ========== VALIDATIONS FINALES ==========
    // Avertir si scores acad√©miques absents
    if (scoreF === 0 && scoreM === 0) {
      ErrorReporter.warn('prepareStudentForAlgorithm',
        `Classe ${className}: √©l√®ve ${id} sans scores acad√©miques (scoreF et scoreM √† 0) ‚Üí impact z-scores V4 nul`
      );
    }

    // Avertir si nom/pr√©nom manquants
    if (!firstName && !lastName) {
      ErrorReporter.warn('prepareStudentForAlgorithm',
        `Classe ${className}: √©l√®ve ${id} sans nom ni pr√©nom`
      );
    }

    return normalized;
  }

  /**
   * Normalise les donn√©es d'une classe depuis le format FIN
   * UTILISE COLLECTE R√âCURSIVE pour g√©rer les structures complexes
   * @param {string} className - Nom de la classe
   * @param {*} classData - Donn√©es brutes de la classe
   * @returns {Array|null} Tableau d'√©l√®ves normalis√©s ou null si invalide
   */
  function normalizeClassStudents(className, classData) {
    if (!classData) {
      ErrorReporter.error('normalizeClassStudents', `Classe ${className}: donn√©es nulles ou undefined`);
      return null;
    }

    // ========== COLLECTE R√âCURSIVE ET D√âDUPLIQU√âE ==========
    ErrorReporter.info('normalizeClassStudents', `Classe ${className}: d√©but collecte r√©cursive`);
    const students = collectStudentsRecursive(classData);

    if (students.length === 0) {
      ErrorReporter.error('normalizeClassStudents',
        `Classe ${className}: aucun √©l√®ve trouv√© apr√®s collecte r√©cursive`,
        { dataType: typeof classData, isArray: Array.isArray(classData) }
      );
      return null;
    }

    ErrorReporter.info('normalizeClassStudents',
      `Classe ${className}: ${students.length} √©l√®ve(s) collect√©(s) (d√©dupliqu√©s)`
    );

    // ========== PR√âPARATION POUR ALGORITHME V4 ==========
    const normalized = [];
    let skippedCount = 0;

    students.forEach((student, index) => {
      try {
        const prepared = prepareStudentForAlgorithm(student, className);
        normalized.push(prepared);
      } catch (error) {
        ErrorReporter.error('normalizeClassStudents',
          `Classe ${className}: erreur pr√©paration √©l√®ve #${index} (${student.id || 'ID inconnu'})`,
          { error: error.message, stack: error.stack }
        );
        skippedCount++;
      }
    });

    // ========== RAPPORT FINAL ==========
    if (skippedCount > 0) {
      ErrorReporter.warn('normalizeClassStudents',
        `Classe ${className}: ${skippedCount} √©l√®ve(s) ignor√©(s) sur ${students.length} (erreur pr√©paration)`
      );
    }

    ErrorReporter.info('normalizeClassStudents',
      `Classe ${className}: ${normalized.length} √©l√®ve(s) pr√™ts pour algorithme V4`
    );

    return normalized.length > 0 ? normalized : null;
  }

  /**
   * R√©cup√®re les donn√©es des classes depuis les onglets FIN (avec scores acad√©miques)
   * IMPORTANT: Cette fonction charge DIRECTEMENT depuis les onglets FIN pour avoir
   * acc√®s aux colonnes SCORE F (U) et SCORE M (V)
   */
  function getClassesData() {
    // R√©initialiser le rapport d'erreurs
    ErrorReporter.clear();

    // Si nous avons d√©j√† charg√© les donn√©es FIN en cache, les utiliser
    if (finSheetsDataCache) {
      ErrorReporter.info('getClassesData', 'Utilisation des donn√©es FIN en cache');

      const formattedData = {};

      Object.keys(finSheetsDataCache).forEach(className => {
        const classData = finSheetsDataCache[className];

        // Utiliser la fonction de normalisation
        const normalizedStudents = normalizeClassStudents(className, classData);

        if (normalizedStudents && normalizedStudents.length > 0) {
          formattedData[className] = normalizedStudents;
        } else {
          ErrorReporter.warn('getClassesData',
            `Classe ${className} ignor√©e (aucun √©l√®ve valide apr√®s normalisation)`
          );
        }
      });

      // Afficher le rapport
      ErrorReporter.info('getClassesData',
        `Donn√©es FIN format√©es: ${Object.keys(formattedData).length} classe(s)`
      );
      ErrorReporter.info('getClassesData',
        'D√©tail: ' + Object.entries(formattedData).map(([c, eleves]) => `${c}: ${eleves.length} √©l√®ves`).join(', ')
      );

      // Afficher les erreurs/warnings √† l'utilisateur si n√©cessaire
      if (ErrorReporter.errors.length > 0) {
        ErrorReporter.displayToUser();
      }

      return formattedData;
    }

    // Sinon, fallback sur STATE.students (mode legacy)
    if (!window.STATE || !window.STATE.students) {
      console.error('‚ùå window.STATE.students non disponible et pas de cache FIN');
      return null;
    }

    console.warn('‚ö†Ô∏è Fallback sur STATE.students (peut ne pas contenir les scores acad√©miques)');

    // Extraire les classes depuis les zones droppables du DOM
    const zones = document.querySelectorAll('.droppable-zone[data-classe]');
    const classesData = {};

    zones.forEach(zone => {
      const className = zone.getAttribute('data-classe');
      if (!className) return;

      classesData[className] = [];

      // R√©cup√©rer les cartes √©l√®ves dans cette zone
      const cards = zone.querySelectorAll('.student-card');

      cards.forEach(card => {
        const studentId = card.getAttribute('data-id') || card.getAttribute('data-student-id');
        if (!studentId) return;

        // R√©cup√©rer les donn√©es compl√®tes depuis STATE
        const student = window.STATE.students[studentId];

        if (student) {
          // Extraire TOUS les champs n√©cessaires pour l'algorithme V4
          classesData[className].push({
            id: student.id || studentId,
            firstName: student.firstName || student.prenom || '',
            lastName: student.lastName || student.nom || '',
            class: className,

            // SEXE (colonne E)
            sexe: (student.sexe || student.gender || 'M').toUpperCase(),
            gender: student.gender || student.sexe || 'M',

            // CRIT√àRES COMPORTEMENTAUX
            com: student.com || student.COM || 0,        // Colonne H
            tra: student.tra || student.TRA || 0,        // Colonne I
            part: student.part || student.PART || 0,     // Colonne J
            abs: student.abs || student.ABS || 0,        // Colonne K

            // SCORES ACAD√âMIQUES
            scoreF: student.scoreF || student.scores?.F || 0,  // Colonne U (1-4)
            scoreM: student.scoreM || student.scores?.M || 0,  // Colonne V (1-4)
            score: student.score || student.scoreF || student.scoreM || 0,

            // AUTRES DONN√âES
            // Colonne F : LV2 (ESP par d√©faut si vide)
            lv2: (student.lv2 || student.LV2 || 'ESP').toUpperCase(),
            options: student.options || [],
            scores: student.scores || {}
          });
        }
      });
    });

    console.log('üìä Donn√©es des classes extraites:', Object.keys(classesData));
    console.log('üìä D√©tail:', Object.entries(classesData).map(([c, eleves]) => `${c}: ${eleves.length} √©l√®ves`));

    return classesData;
  }

  /**
   * V√©rifie que les donn√©es sont disponibles
   */
  function validateData() {
    const classesData = getClassesData();

    if (!classesData || Object.keys(classesData).length === 0) {
      console.error('‚ùå Aucune classe trouv√©e dans STATE');
      console.log('Diagnostic :');
      console.log('- STATE existe :', !!window.STATE);
      console.log('- STATE.students existe :', !!window.STATE?.students);
      console.log('- Nombre d\'√©l√®ves :', Object.keys(window.STATE?.students || {}).length);
      return false;
    }

    return true;
  }

  /**
   * Ouvre l'interface du module Groupes V4
   * CHARGE AUTOMATIQUEMENT LES ONGLETS FIN AVEC SCORES (colonnes U et V)
   */
  async function openModuleGroupsV4(mode) {
    console.log('üöÄ Ouverture du module Groupes V4, mode:', mode);

    // V√©rifier les d√©pendances
    if (!window.GroupsInterfaceV4) {
      console.error('‚ùå GroupsInterfaceV4 non charg√©');
      alert('Erreur : Interface Groupes V4 non disponible');
      return;
    }

    if (!window.GroupsAlgorithmV4) {
      console.error('‚ùå GroupsAlgorithmV4 non charg√©');
      alert('Erreur : Algorithme Groupes V4 non disponible');
      return;
    }

    // üîë CHARGER LES DONN√âES FIN AVEC SCORES (colonnes U et V)
    console.log('üì° Chargement des onglets FIN avec SCORE F (colonne U) et SCORE M (colonne V)...');
    const finData = await loadFINData();

    if (!finData || Object.keys(finData).length === 0) {
      console.error('‚ùå Aucune donn√©e FIN charg√©e');

      // Fallback sur STATE.students
      console.warn('‚ö†Ô∏è Fallback sur STATE.students...');

      // V√©rifier que STATE.students est charg√©
      if (!window.STATE || !window.STATE.students || Object.keys(window.STATE.students).length === 0) {
        console.warn('‚ö†Ô∏è STATE.students vide ou non charg√©, attente...');

        // Attendre 1 seconde que les donn√©es se chargent
        setTimeout(() => {
          if (!window.STATE || !window.STATE.students || Object.keys(window.STATE.students).length === 0) {
            alert('Erreur : Les donn√©es des √©l√®ves ne sont pas encore charg√©es. Veuillez attendre la fin du chargement et r√©essayer.');
            console.error('‚ùå STATE.students toujours vide apr√®s d√©lai');
            return;
          }
          // R√©essayer l'ouverture
          openModuleGroupsV4(mode);
        }, 1000);
        return;
      }

      // Valider les donn√©es
      if (!validateData()) {
        alert('Erreur : Aucune classe disponible. Veuillez charger des donn√©es d\'abord.');
        return;
      }
    } else {
      console.log('‚úÖ Donn√©es FIN charg√©es avec succ√®s:', Object.keys(finData).length, 'classes');
    }

    // Cr√©er le container plein √©cran
    if (!moduleContainer) {
      moduleContainer = document.createElement('div');
      moduleContainer.id = 'groups-v4-container';
      moduleContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 9999;
        background: white;
      `;

      // Ajouter un bouton de fermeture
      const closeBtn = document.createElement('button');
      closeBtn.innerHTML = '<i class="fas fa-times"></i> Fermer';
      closeBtn.style.cssText = `
        position: absolute;
        top: 16px;
        right: 16px;
        z-index: 10000;
        padding: 8px 16px;
        background: #ef4444;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      `;
      closeBtn.addEventListener('click', closeModuleGroupsV4);

      moduleContainer.appendChild(closeBtn);
      document.body.appendChild(moduleContainer);
    }

    // Rendre l'interface triptyque
    window.GroupsInterfaceV4.renderInitialStructure(moduleContainer);

    // Afficher le container
    moduleContainer.style.display = 'block';

    console.log('‚úÖ Module Groupes V4 ouvert');
  }

  /**
   * Ferme l'interface du module
   */
  function closeModuleGroupsV4() {
    if (moduleContainer) {
      moduleContainer.style.display = 'none';
      console.log('‚úÖ Module Groupes V4 ferm√©');
    }
  }

  /**
   * G√®re l'√©v√©nement de g√©n√©ration des groupes
   */
  function handleGenerateGroups(event) {
    const { scenario, mode, selectedLanguage, regroupements } = event.detail;

    console.log('üéØ G√©n√©ration des groupes demand√©e:', { scenario, mode, selectedLanguage, regroupements });

    try {
      // Pour chaque regroupement, g√©n√©rer les groupes
      const allResults = regroupements.map(regroupement => {
        // R√©cup√©rer les √©l√®ves des classes du regroupement
        const classesData = getClassesData();
        let students = [];

        // Si aucune classe sp√©cifi√©e, prendre toutes les classes
        const classesToUse = regroupement.classes.length > 0
          ? regroupement.classes
          : Object.keys(classesData);

        classesToUse.forEach(className => {
          if (classesData[className]) {
            students.push(...classesData[className]);
          }
        });

        console.log(`üìö Regroupement "${regroupement.name}" : ${students.length} √©l√®ves (avant filtrage)`);

        // FILTRAGE PAR LANGUE pour le sc√©nario LV2
        if (scenario === 'lv2' && selectedLanguage) {
          const beforeFilter = students.length;
          students = students.filter(student => {
            const studentLang = (student.lv2 || 'ESP').toUpperCase();
            return studentLang === selectedLanguage;
          });
          console.log(`üåç Filtrage LV2 (${selectedLanguage}): ${beforeFilter} ‚Üí ${students.length} √©l√®ves`);
        }

        if (students.length === 0) {
          console.warn(`‚ö†Ô∏è Aucun √©l√®ve pour "${regroupement.name}" apr√®s filtrage`);
          return null;
        }

        console.log(`üìö Regroupement "${regroupement.name}" : ${students.length} √©l√®ves (apr√®s filtrage)`);

        // Appeler l'algorithme
        const result = window.GroupsAlgorithmV4.distribute({
          students,
          mode,
          numGroups: regroupement.numGroups,
          scenario
        });

        return {
          regroupement: regroupement.name,
          result
        };
      });

      // Filtrer les r√©sultats null (regroupements vides)
      const validResults = allResults.filter(r => r !== null);

      if (validResults.length === 0) {
        throw new Error('Aucun √©l√®ve trouv√© apr√®s filtrage. V√©rifiez la langue s√©lectionn√©e et les classes.');
      }

      // Combiner les r√©sultats en pr√©servant l'information du regroupement
      const combinedResults = {
        groups: validResults.flatMap(r =>
          r.result.groups.map(group => ({
            ...group,
            regroupementName: r.regroupement, // Ajouter le nom du regroupement
            regroupementId: r.regroupement.replace(/\s+/g, '-').toLowerCase()
          }))
        ),
        stats: validResults.flatMap(r => r.result.stats),
        metadata: {
          scenario,
          mode,
          selectedLanguage,
          totalRegroupements: validResults.length,
          totalStudents: validResults.reduce((sum, r) => sum + r.result.metadata.totalStudents, 0),
          timestamp: new Date().toISOString()
        }
      };

      // √âmettre l'√©v√©nement de succ√®s
      const successEvent = new CustomEvent('groups:generated', {
        detail: combinedResults
      });
      document.dispatchEvent(successEvent);

      console.log('‚úÖ Groupes g√©n√©r√©s avec succ√®s', combinedResults);

    } catch (error) {
      console.error('‚ùå Erreur lors de la g√©n√©ration:', error);

      // √âmettre l'√©v√©nement d'erreur
      const errorEvent = new CustomEvent('groups:error', {
        detail: { message: error.message }
      });
      document.dispatchEvent(errorEvent);
    }
  }

  /**
   * G√®re l'√©v√©nement de r√©sultats g√©n√©r√©s
   */
  function handleGroupsGenerated(event) {
    console.log('üìä R√©sultats re√ßus:', event.detail);

    // Afficher les r√©sultats dans l'interface
    if (window.GroupsInterfaceV4) {
      window.GroupsInterfaceV4.displayResults(event.detail);
    }
  }

  /**
   * G√®re l'√©v√©nement d'erreur
   */
  function handleGroupsError(event) {
    console.error('‚ùå Erreur re√ßue:', event.detail);

    // Afficher l'erreur dans l'interface
    if (window.GroupsInterfaceV4) {
      window.GroupsInterfaceV4.displayError(event.detail);
    }
  }

  /**
   * Remplace la fonction openGroupsInterface existante
   */
  function replaceOpenGroupsInterface() {
    // Sauvegarder l'ancienne fonction si elle existe
    if (window.openGroupsInterface) {
      window._oldOpenGroupsInterface = window.openGroupsInterface;
      console.log('üíæ Ancienne openGroupsInterface sauvegard√©e');
    }

    // Remplacer par la nouvelle
    window.openGroupsInterface = function(mode) {
      console.log('üîÑ openGroupsInterface appel√©e avec mode:', mode);

      // Rediriger vers le module V4
      openModuleGroupsV4(mode);
    };

    console.log('‚úÖ openGroupsInterface remplac√©e par la version V4');
  }

  /**
   * Restaure l'ancienne fonction openGroupsInterface
   */
  function restoreOpenGroupsInterface() {
    if (window._oldOpenGroupsInterface) {
      window.openGroupsInterface = window._oldOpenGroupsInterface;
      delete window._oldOpenGroupsInterface;
      console.log('‚úÖ openGroupsInterface restaur√©e');
    }
  }

  /**
   * Initialisation du module
   */
  function init() {
    // √âcouter les √©v√©nements
    document.addEventListener('groups:generate', handleGenerateGroups);
    document.addEventListener('groups:generated', handleGroupsGenerated);
    document.addEventListener('groups:error', handleGroupsError);

    // Remplacer la fonction du header
    replaceOpenGroupsInterface();

    // Exposer les fonctions globalement
    window.openModuleGroupsV4 = openModuleGroupsV4;
    window.closeModuleGroupsV4 = closeModuleGroupsV4;

    console.log('‚úÖ Module Groupes V4 initialis√© et connect√© au header');
  }

  // Initialiser au chargement du DOM
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    // DOM d√©j√† charg√©
    setTimeout(init, 100);
  }

  // Nettoyer √† la fermeture
  window.addEventListener('beforeunload', () => {
    restoreOpenGroupsInterface();
  });

})();
</script>
