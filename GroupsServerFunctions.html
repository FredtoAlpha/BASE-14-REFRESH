<script>
/**
 * GROUPS MODULE V4 - FONCTIONS SERVEUR
 * Fonctions Apps Script pour sauvegarder et charger les groupes dans Google Sheets
 */

/**
 * Sauvegarde les groupes dans des onglets Google Sheets (VERSION V4)
 * @param {Array} groupsData - Tableau d'objets {sheetName, students, metadata}
 * @param {boolean} isTemp - Si true, cr√©er onglets TEMP, sinon d√©finitifs
 * @returns {Object} R√©sultat {success, created, updated, deleted, sheetNames, error}
 */
function saveGroupsToSheetsV4(groupsData, isTemp) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const result = {
      success: true,
      created: 0,
      updated: 0,
      deleted: 0,
      sheetNames: []
    };

    // Si finalisation (isTemp = false), supprimer d'abord tous les onglets TEMP
    if (!isTemp) {
      const allSheets = ss.getSheets();
      allSheets.forEach(sheet => {
        const name = sheet.getName();
        if (name.includes('TEMP') && name.match(/^6¬∞Grp(B|LV|Op)\d+TEMP$/)) {
          ss.deleteSheet(sheet);
          result.deleted++;
          Logger.log('üóëÔ∏è Onglet TEMP supprim√©: ' + name);
        }
      });
    }

    // Cr√©er ou mettre √† jour chaque onglet de groupe
    groupsData.forEach(groupData => {
      const sheetName = groupData.sheetName;
      let sheet = ss.getSheetByName(sheetName);

      if (sheet) {
        // Onglet existe ‚Üí mise √† jour
        sheet.clear();
        result.updated++;
        Logger.log('üîÑ Mise √† jour onglet: ' + sheetName);
      } else {
        // Cr√©er nouvel onglet
        sheet = ss.insertSheet(sheetName);
        result.created++;
        Logger.log('‚úÖ Cr√©ation onglet: ' + sheetName);
      }

      // √âcrire les en-t√™tes (SOURCE en colonne O = position 15)
      const headers = ['ID', 'NOM', 'PRENOM', 'SEXE', 'CLASSE', 'SCORE F', 'SCORE M', 'COM', 'TRA', 'PART', 'ABS', 'LV2', 'OPTIONS', '', 'SOURCE'];
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]);

      // Formater les en-t√™tes
      sheet.getRange(1, 1, 1, headers.length)
        .setBackground('#4a90e2')
        .setFontColor('#ffffff')
        .setFontWeight('bold')
        .setHorizontalAlignment('center');

      // √âcrire les donn√©es des √©l√®ves (SOURCE en colonne O = position 15)
      if (groupData.students.length > 0) {
        const rows = groupData.students.map(student => {
          const scoreF = parseFloat(student.scoreF) || 0;
          const scoreM = parseFloat(student.scoreM) || 0;
          const com = parseFloat(student.com) || 0;
          const tra = parseFloat(student.tra) || 0;
          const part = parseFloat(student.part) || 0;
          const abs = parseFloat(student.abs) || 0;
          const lv2 = (student.lv2 || '').toString().trim().toUpperCase();

          let optionsArray = [];
          if (Array.isArray(student.options)) {
            optionsArray = student.options;
          } else if (typeof student.options === 'string' && student.options.trim() !== '') {
            optionsArray = student.options.split(/[;,]/).map(opt => opt.trim()).filter(Boolean);
          }
          const optionsString = optionsArray.join(';');

          const sourceClass = (student.source || student.SOURCE || student._SOURCE_CLASS || student.classe || '').toString().trim();

          return [
            (student.id || '').toString().trim(),
            (student.nom || student.lastName || '').toString().trim(),
            (student.prenom || student.firstName || '').toString().trim(),
            (student.sexe || student.gender || '').toString().trim().toUpperCase(),
            (student.classe || student.class || student.className || '').toString().trim(),
            scoreF,
            scoreM,
            com,
            tra,
            part,
            abs,
            lv2,
            optionsString,
            '',
            sourceClass || (student.classe || student.class || '')
          ];
        });

        sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
      }

      // Ajouter m√©tadonn√©es en bas de l'onglet (lignes cach√©es)
      const metaRow = groupData.students.length + 3;
      sheet.getRange(metaRow, 1, 1, 2).setValues([['METADATA', JSON.stringify(groupData.metadata)]]);
      sheet.getRange(metaRow, 1, 1, 2).setBackground('#f3f4f6').setFontSize(8);

      // Formater les colonnes
      sheet.autoResizeColumns(1, headers.length);
      sheet.setFrozenRows(1);

      // Alterner les couleurs des lignes
      if (groupData.students.length > 0) {
        for (let i = 2; i <= groupData.students.length + 1; i++) {
          const color = i % 2 === 0 ? '#f9fafb' : '#ffffff';
          sheet.getRange(i, 1, 1, headers.length).setBackground(color);
        }
      }

      result.sheetNames.push(sheetName);
    });

    Logger.log('‚úÖ Sauvegarde r√©ussie: ' + JSON.stringify(result));
    return result;

  } catch (error) {
    Logger.log('‚ùå Erreur saveGroupsToSheetsV4: ' + error.toString());
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Charge les groupes depuis les onglets Google Sheets (VERSION V4)
 * Recherche tous les onglets commen√ßant par "6¬∞Grp" (B/LV/Op) avec ou sans TEMP
 * @returns {Object} R√©sultat {success, groups, sheetNames, error}
 */
function loadGroupsFromSheetsV4() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const allSheets = ss.getSheets();
    const result = {
      success: true,
      groups: [],
      sheetNames: []
    };

    // Pattern pour identifier les onglets de groupes
    const pattern = /^6¬∞Grp(B|LV|Op)(\d+)(TEMP)?$/;

    allSheets.forEach(sheet => {
      const name = sheet.getName();
      const match = name.match(pattern);

      if (match) {
        Logger.log('üìÇ Chargement onglet: ' + name);

        // Lire les donn√©es
        const dataRange = sheet.getDataRange();
        const values = dataRange.getValues();

        if (values.length < 2) {
          Logger.log('‚ö†Ô∏è Onglet vide: ' + name);
          return;
        }

        // Extraire les √©l√®ves (lignes 2 √† n)
        const students = [];
        for (let i = 1; i < values.length; i++) {
          const row = values[i];

          // Si ligne de m√©tadonn√©es, arr√™ter
          if (row[0] === 'METADATA') break;

          // Si ligne vide, continuer
          if (!row[0]) continue;

          const classe = (row[4] || '').toString().trim();
          const sourceClass = (row[14] || row[4] || '').toString().trim() || classe;
          const rawOptions = row[12];

          let options = [];
          let optionsString = '';
          if (Array.isArray(rawOptions)) {
            options = rawOptions.filter(Boolean).map(opt => opt.toString().trim()).filter(Boolean);
            optionsString = options.join(';');
          } else if (typeof rawOptions === 'string' && rawOptions.trim() !== '') {
            options = rawOptions.split(/[;,]/).map(opt => opt.trim()).filter(Boolean);
            optionsString = rawOptions.trim();
          }

          const lv2 = (row[11] || '').toString().trim().toUpperCase() || 'ESP';
          const scoreF = parseFloat(row[5]) || 0;
          const scoreM = parseFloat(row[6]) || 0;
          const com = parseFloat(row[7]) || 0;
          const tra = parseFloat(row[8]) || 0;
          const part = parseFloat(row[9]) || 0;
          const abs = parseFloat(row[10]) || 0;

          students.push({
            id: (row[0] || '').toString().trim(),
            nom: (row[1] || '').toString().trim(),
            lastName: (row[1] || '').toString().trim(),
            prenom: (row[2] || '').toString().trim(),
            firstName: (row[2] || '').toString().trim(),
            sexe: (row[3] || '').toString().trim().toUpperCase(),
            class: classe,
            classe: classe,
            className: classe,
            scoreF: scoreF,
            scoreM: scoreM,
            com: com,
            tra: tra,
            part: part,
            abs: abs,
            scores: {
              F: scoreF,
              M: scoreM,
              COM: com,
              TRA: tra,
              PART: part,
              ABS: abs
            },
            lv2: lv2,
            LV2: lv2,
            opt: optionsString,
            options: options,
            optionsList: options,
            source: sourceClass,
            SOURCE: sourceClass,
            _SOURCE_CLASS: sourceClass
          });
        }

        // Chercher les m√©tadonn√©es
        let metadata = null;
        for (let i = values.length - 1; i >= 0; i--) {
          if (values[i][0] === 'METADATA') {
            try {
              metadata = JSON.parse(values[i][1]);
            } catch (e) {
              Logger.log('‚ö†Ô∏è M√©tadonn√©es invalides dans ' + name);
            }
            break;
          }
        }

        // Si pas de m√©tadonn√©es, en cr√©er des basiques
        if (!metadata) {
          const prefix = match[1];
          const scenarioMap = { 'B': 'besoins', 'LV': 'lv2', 'Op': 'options' };
          metadata = {
            groupId: parseInt(match[2]),
            groupName: 'Groupe ' + match[2],
            regroupementName: 'Regroupement',
            scenario: scenarioMap[prefix] || 'besoins',
            mode: 'heterogeneous',
            isTemp: !!match[3],
            timestamp: new Date().toISOString()
          };
        }

        result.groups.push({
          students: students,
          metadata: metadata
        });

        result.sheetNames.push(name);
      }
    });

    // Trier les groupes par groupId
    result.groups.sort((a, b) => a.metadata.groupId - b.metadata.groupId);

    Logger.log('‚úÖ Chargement r√©ussi: ' + result.groups.length + ' groupe(s)');
    return result;

  } catch (error) {
    Logger.log('‚ùå Erreur loadGroupsFromSheetsV4: ' + error.toString());
    return {
      success: false,
      error: error.toString(),
      groups: [],
      sheetNames: []
    };
  }
}
</script>
